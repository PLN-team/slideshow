```{r setup-oaks, include=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)  # data manipulation
library(PLNmodels)  # plot of covariance/correlation matrices
library(corrplot)   # plot of covariance/correlation matrices
```

```{r future, echo = FALSE}
options(future.fork.enable = TRUE)
future::plan("multicore", workers = 10)
```

---

# Illustration in genomics

## scRNA data set 

The dataset `scRNA` contains the counts of the 500 most varying transcripts in the mixtures of 5 cell lines in human liver (obtained with standard 10x scRNAseq Chromium protocol).

We subsample 500 random cells and the keep the 200 most varying genes

```{r init-data, echo = FALSE}
library(PLNmodels); library(ZIPLN)
```

```{r scRNA-dataset}
data(scRNA); set.seed(1234)
train_set <- sample.int(nrow(scRNA), 500)
test_set  <- setdiff(1:nrow(scRNA), train_set)
scRNA_train <- scRNA[train_set, ]
scRNA_test  <- scRNA[test_set, ]
scRNA_train$counts <- scRNA_train$counts[, 1:200]
scRNA_test$counts  <- scRNA_test$counts[, 1:200]
```

### Covariates

- `cell_line`: the cell line of the current row (among 5)
- `total_counts`: Total number reads for that cell

---

# Table of Counts

.pull-left[
Matrix view (log-transform + total-counts normalization)

```{r glance counts, fig.height=6, fig.cap="log-scaled counts", echo = FALSE}
log_data <- sweep(log(1 + scRNA_train$counts), 1, log(scRNA_train$total_counts), "-")
log_data %>% 
  corrplot::corrplot(is.corr = FALSE,
    addgrid.col = NA,  tl.cex = .5,  cl.pos = "n", tl.pos = "n")
```
]

.pull-right[
Histogram (log-transform + total-counts normalization)
```{r glimpse Abundance, echo = FALSE}
ggplot(data.frame(counts = c(log_data)), aes(counts))  + 
  geom_histogram() + theme_bw()
```
]

---
#  PLN with offsets and covariates

- Cell-line effect is in the regression coefficient (groupwise or common mean)
- Spurious effect regarding the interactions between genes (full or diagonal covariance).

## Offset: .small[modeling sampling effort]

The predefined offset uses the total sum of reads.

```{r simple PLN offsets, cache = TRUE, results = FALSE}
M01_scRNA <- PLN(counts ~ 1 + offset(log(total_counts)), scRNA_train)
M02_scRNA <- PLN(counts ~ 1 + offset(log(total_counts)), scRNA_train,
                 control = PLN_param(covariance = "diagonal"))
```

## Covariates: .small[cell-line effect ('ANOVA'-like) ]

The `cell_line` is a natural candidate for explaining a large of the variance.

```{r PLN covariate cell_line, cache = TRUE, results = FALSE}
M11_scRNA <- PLN(counts ~ 0 + cell_line + offset(log(total_counts)), scRNA_train)
M12_scRNA <- PLN(counts ~ 0 + cell_line + offset(log(total_counts)), scRNA_train,
                 control = PLN_param(covariance = "diagonal"))
```

---
#  PLN with offsets and covariates (2)

There is a clear gain in introducing the cell_line covariate in the model:

```{r PLN covariate oaks results, echo = TRUE}
rbind(M01 = M01_scRNA$criteria, M02 = M02_scRNA$criteria, 
      M11 = M11_scRNA$criteria, M12 = M12_scRNA$criteria) %>% 
  knitr::kable(format = "html")
```

---
#  PLN with offsets and covariates (3)

Looking at the coefficients $\mathbf{B}$ associated with `cell_line` bring additional insights:

```{r scRNA matrix plot, fig.width=6, fig.height=6, echo = FALSE, fig.align='center'}
heatmap(coef(M12_scRNA))
```

---

# Discriminant Analysis  (scRNA, 1)

Use the `cell-line` variable for grouping (`grouping` is a factor of group to be considered)

```{r PLNLDA-oaks, cache=TRUE, results=FALSE}
myLDA_cell_line <- 
  PLNLDA(counts ~ 1 + offset(log(total_counts)), grouping = cell_line,
         data = scRNA_train)
```

.pull-left[
```{r plot-lda-oaks1, echo = FALSE, fig.height = 6}
plot(myLDA_cell_line, map = "individual")
```
]

.pull-right[
```{r plot-lda-oaks2, echo = FALSE, fig.height = 6}
plot(myLDA_cell_line, map = "variable")
```
]

---
# Discriminant Analysis  (scRNA, 2)

Consider now a diagonal covariance.

```{r PLNLDA-oaks-diag, cache=TRUE, results=FALSE}
myLDA_cell_line_diag <- 
  PLNLDA(counts ~ 1 + offset(log(total_counts)), grouping = cell_line,
         data = scRNA_train, control = PLN_param(covariance = "diagonal"))
```

.pull-left[
```{r plot-lda-diag-oaks1, echo = FALSE, fig.height = 6}
plot(myLDA_cell_line_diag, map = "individual")
```
]

.pull-right[
```{r plot-lda-diag-oaks2, echo = FALSE, fig.height = 6}
plot(myLDA_cell_line_diag, map = "variable")
```
]

---
# Discriminant Analysis (scRNA, 3)

We can prediction cell-line of some new data: let us try either diagonal or fully parametrized covariance.

```{r, pred-scRNA, cache = TRUE}
pred_cell_line      <- predict(myLDA_cell_line     ,
                               newdata = scRNA_test, type = "response")
pred_cell_line_diag <- predict(myLDA_cell_line_diag,
                               newdata = scRNA_test, type = "response")
```

The ARI on the test set is impressive.footnote[The problem should be easy though...]

```{r, ari-lda-pred-scRNA}
aricode::ARI(pred_cell_line, scRNA_test$cell_line)
aricode::ARI(pred_cell_line_diag, scRNA_test$cell_line)
```

---
# Discriminant Analysis  (scRNA, 4)

Let us explore the discriminant groups: 

```{r LDA-heatmap-factors, fig.align='center'}
heatmap(exp(myLDA_cell_line$group_means))
```

Indeed, some groups of gene caracterize well the cell-lines.

---
# A PCA analysis of the scRNA data set (1)

```{r PLNPCA offset, cache.rebuild= TRUE, warning=FALSE, message=FALSE, results='hide'}
PCA_scRNA <- PLNPCA(counts ~ 1 + offset(log(total_counts)), data = scRNA_train,
                    ranks = c(1, 2, seq(5, 40, 5)))
```

### Model Selection
```{r PCA offset vizu cell-line, fig.width=6, fig.height=6, fig.align="center", echo=FALSE}
plot(PCA_scRNA)
myPCA_scRNA <- getBestModel(PCA_scRNA, "BIC")
```

---
# A PCA analysis of the scRNA data set  (2)

### Biplot

Individual + Factor map - 40 most contributing genes

<small>
```{r PCA offset vizu tree, fig.width=6, fig.height=6, fig.align="center", echo=FALSE}
myPCA_scRNA %>% factoextra::fviz_pca_biplot(
  select.var = list(contrib = 40), addEllipses = TRUE, habillage = scRNA_train$cell_line,
  title = "Biplot (50 most contributing genes)"
  ) + labs(col = "tree status") + scale_color_viridis_d()
```
</small>

---
# Availability

### Help and documentation

- github group <https://github.com/pln-team>
- PLNmodels website <https://pln-team.github.io/PLNmodels> 

### R/C++ Package `PLNmodels`

Last stable release on CRAN,  development version available on GitHub).

```{r install, eval=FALSE, tidy=FALSE}
install.packages("PLNmodels")
remotes::install_github("PLN-team/PLNmodels@dev")
```

```{r loading package, message=FALSE}
library(PLNmodels)
packageVersion("PLNmodels")
```

### Python module `pyPLNmodels`

A PyTorch implementation is available in pyPI [https://pypi.org/project/pyPLNmodels/](https://pypi.org/project/pyPLNmodels/)

---
# Simple torch example in `R` 

```{r, cache.rebuild=TRUE,  torch-vs-nlopt}
data("oaks")
system.time(myPLN_torch <-
              PLN(Abundance ~ 1  + offset(log(Offset)),
                  data = oaks, control = PLN_param(backend = "torch", trace = 0)))
system.time(myPLN_nlopt <-
              PLN(Abundance ~ 1  + offset(log(Offset)),
                  data = oaks, control = PLN_param(backend = "nlopt", trace = 0)))
```

```{r}
myPLN_torch$loglik
myPLN_nlopt$loglik
```

